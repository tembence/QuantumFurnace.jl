var documenterSearchIndex = {"docs":
[{"location":"generated/theory_detailed_balance/#Detailed-balanced-Lindbladian","page":"Detailed Balanced Lindbladian","title":"Detailed balanced Lindbladian","text":"","category":"section"},{"location":"generated/theory_detailed_balance/","page":"Detailed Balanced Lindbladian","title":"Detailed Balanced Lindbladian","text":"","category":"page"},{"location":"generated/theory_detailed_balance/","page":"Detailed Balanced Lindbladian","title":"Detailed Balanced Lindbladian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Here you can find a detailed list of all functions exported by QuantumFurnace.jl.","category":"page"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/#QuantumFurnace.LiouvConfig","page":"API Reference","title":"QuantumFurnace.LiouvConfig","text":"LiouvConfig\n\nA configuration object that holds all the parameters for the core function: run_liouvillian, which constructs the Lindbladian of the thermalizing system.\n\nFields\n\nnum_qubits::Int64: The number of system qubits.\nwith_coherent::Bool: The option to add (=true) or omit (=false) the coherent term in the Lindbladian.\n\nIf added, the target state of the evolution will be the exactly the Gibbs state, otherwise only approximately.\n\nwith_linear_combination::Bool: The option to choose if we want to apply a convex combination of Lindbladians for a faster mixing. Could add extra complexities if the resulting transition function is not smooth. (See more in Theory).\na::Float64 and b::Float64: The parameters that specify the type of linear combination.\neta::Float64: in the case of the Metropolis linear combination, η is an additional coefficient that determines the accuracy of the time domain approximation.\ndomain::AbstractDomain: The domain the simulation runs in (BOHR, ENERGY, TIME, TROTTER). The choice of the domain represents the levels of approximations we need to get form theory down to quantum circuitry.\nnum_energy_bits::Int64: Determines the how coarse the energy and time grid is and thus how accurate the approximations between each domain are.\nt0::Float64 and w0::Float64: are the time and energy units we are working with in the Riemann summed integrals. Of course, the smaller the better but also the costlier, and the two are intertwined due to Fourier: ω₀t₀ = 2π / N.\nnum_trotter_steps_per_t0::Int64: The number of Trotter steps used for a unit of time t₀.\n\nCurrently possible linear combinations:\n\n(a, b) = \n\n(0, 0) - no linear combination, simple Gaussian\n(>0, 0) - linear combination that results in Metropolis-like transition\n(>0, >0) - linear combination that results in Glauber transition (smoother)\n\nAvailable domains:\n\nThe domain field can be set to one of the following options:\n\nBohrDomain(): The highest level domain where the jump operators and thus the Lindbladian are written in a decomposition of Bohr frequencies.\nEnergyDomain(): A level lower, in which the operators are approximated by energy integrals.\nTimeDomain(): Another level lower, in which the energy approximates are written up as Fourier's of the temporal equals.\nTrotterDomain(): The lowest level, thus also the only one implementable on a quantum computer, in which all time evolutions are replaced via their Trotter series.\n\n\n\n\n\n","category":"type"},{"location":"generated/theory_oqs_dynamics/#Open-Quantum-System-Dynamics","page":"Open Quantum System Dynamics","title":"Open Quantum System Dynamics","text":"","category":"section"},{"location":"generated/theory_oqs_dynamics/","page":"Open Quantum System Dynamics","title":"Open Quantum System Dynamics","text":"","category":"page"},{"location":"generated/theory_oqs_dynamics/","page":"Open Quantum System Dynamics","title":"Open Quantum System Dynamics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/theory_weak_measurement/#Weak-measurement-based-Lindbladian-evolution","page":"Weak-measurement based Lindbladian Evolution","title":"Weak measurement based Lindbladian evolution","text":"","category":"section"},{"location":"generated/theory_weak_measurement/","page":"Weak-measurement based Lindbladian Evolution","title":"Weak-measurement based Lindbladian Evolution","text":"","category":"page"},{"location":"generated/theory_weak_measurement/","page":"Weak-measurement based Lindbladian Evolution","title":"Weak-measurement based Lindbladian Evolution","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorial_lindbladian/#Constructing-a-Detailed-Balanced-Lindbladian","page":"Constructing the Detailed Balanced Lindbladian","title":"Constructing a Detailed Balanced Lindbladian","text":"","category":"section"},{"location":"generated/tutorial_lindbladian/","page":"Constructing the Detailed Balanced Lindbladian","title":"Constructing the Detailed Balanced Lindbladian","text":"","category":"page"},{"location":"generated/tutorial_lindbladian/","page":"Constructing the Detailed Balanced Lindbladian","title":"Constructing the Detailed Balanced Lindbladian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorial_hamiltonian/#Create-a-Hamiltonian","page":"Create a Hamiltonian","title":"Create a Hamiltonian","text":"","category":"section"},{"location":"generated/tutorial_hamiltonian/","page":"Create a Hamiltonian","title":"Create a Hamiltonian","text":"","category":"page"},{"location":"generated/tutorial_hamiltonian/","page":"Create a Hamiltonian","title":"Create a Hamiltonian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorial/#Open-Quantum-System-Evolution","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"","category":"section"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"In this tutorial, we will walk through the process of finding the steady-state thermal density matrix rho_ss for a system coupled to a thermal bath. The evolution of such a system is governed by the Lindblad master equation:","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"fracdrhodt = -iH rho + sum_k gamma_k left( L_k rho L_k^dagger - frac12L_k^dagger L_k rho right)","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"Our goal is to find the state rho_ss where fracdrhodt = 0.","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"using QuantumFurnace\nusing LinearAlgebra","category":"page"},{"location":"generated/tutorial/#Step-1:-Define-the-System","page":"Open Quantum System Evolution","title":"Step 1: Define the System","text":"","category":"section"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"First, we define the system's Hamiltonian H. We'll use a simple two-qubit Heisenberg model.","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"num_qubits = 2","category":"page"},{"location":"generated/tutorial/#Step-2:-Define-the-Environment","page":"Open Quantum System Evolution","title":"Step 2: Define the Environment","text":"","category":"section"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"Next, we define the jump operators L and the temperature T.","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"temperature = 0.5\ndomain = TimeDomain()","category":"page"},{"location":"generated/tutorial/#Step-3:-Solve-for-the-Thermal-State","page":"Open Quantum System Evolution","title":"Step 3: Solve for the Thermal State","text":"","category":"section"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"Now, we can call our main solver function.","category":"page"},{"location":"generated/tutorial/#Step-4:-Analyze-the-Result","page":"Open Quantum System Evolution","title":"Step 4: Analyze the Result","text":"","category":"section"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"The resulting density matrix should have a trace of 1.","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"","category":"page"},{"location":"generated/tutorial/","page":"Open Quantum System Evolution","title":"Open Quantum System Evolution","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/theory_convex_combination/#Convex-Combination-of-Lindbladians","page":"Convex Combination of Lindbladians","title":"Convex Combination of Lindbladians","text":"","category":"section"},{"location":"generated/theory_convex_combination/","page":"Convex Combination of Lindbladians","title":"Convex Combination of Lindbladians","text":"","category":"page"},{"location":"generated/theory_convex_combination/","page":"Convex Combination of Lindbladians","title":"Convex Combination of Lindbladians","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#QuantumFurnace.jl","page":"Home","title":"QuantumFurnace.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for QuantumFurnace.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A high-performance Julia package for simulating open quantum systems that prepare quantum Gibbs states. QuantumFurnace is a framework in which the user can both learn about the details of quantum Gibbs sampling, and also research the topic further with the efficient implementations provided here. This project serves as a complementary resource to the recent papers [CKBG23, CKG23] that achieved a breakthrough in the theory of quantum Gibbs sampling. ","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[CKBG23]   Chen, C.F., Kastoryano, M.J., Brandão, F.G. and Gilyén, A., 2023. Quantum thermal state preparation. arXiv:2303.18224.\n\n[CKG23]    Chen, C.F., Kastoryano, M.J. and Gilyén, A., 2023. An efficient and exact noncommutative quantum Gibbs sampler. arXiv:2311.09207.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are new, we recommend starting with the Tutorials to see how to solve common problems. For a detailed breakdown of all available functions, please see the API Reference.","category":"page"},{"location":"generated/tutorial_thermalize/#Finding-a-Thermal-State","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"","category":"section"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"In this tutorial we will give more details on one of the core functions of the software package: on how to drive a given quantum system to the thermal state via a simulated open quantum system evolution. We will see how to set up everything for the function run_thermalization and also what it actually does behind the curtains.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"In summary, run_thermalization takes in a basic set of configurations (number of qubits, temperature, etc.), the Hamiltonian H that describes the system, an initial state rho_0 where the evolution starts from and the set of jumps A^a that prescribe that evolution. It will simulate the open quantum system evolution or Lindbladian evolution with a weak-measurement based algorithm. You can read more about them in the Theory section if you follow the links. Here, it is enough to just think of it as the following process:","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Start from an initial density matrix rho_0.\nEvolve it for a short delta amount of time, rho_delta = (mathbb1 + delta mathcalL)rho_0 + mathcalO(delta^2) simeq e^delta mathcalL(rho_0).\nRepeat until rho_t gets close enough to the target state sigma_beta = e^-beta H  Z, i.e. the Gibbs state.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Here the magic is still hidden in the generator mathcalL, but the crucial property it has is that the dynamics it generates, given by e^t mathcalL, has the Gibbs state as its unique fixed point. Thus if we evolve the system for a long enough time all other contribution will decay and the only state that survives is the Gibbs state.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Let us go through the main steps of the code:","category":"page"},{"location":"generated/tutorial_thermalize/#1.-Configure-the-algorithm-parameters","page":"Finding a Thermal State","title":"1. Configure the algorithm parameters","text":"","category":"section"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"using QuantumFurnace\nusing LinearAlgebra\n\nnum_qubits = 3\ndim = 2^num_qubits\nnum_energy_bits = 10\nbeta = 10.0\nw0 = 0.05                            # Energy estimating precision\nt0 = 2pi / (2^num_energy_bits * w0)  # Time estimating precision\n\ndomain = TimeDomain()\n\nwith_coherent = true                  # For exact detailed balance\nwith_linear_combination = false       # Gaussian transitions\na = 0.0\nb = 0.0\neta = 0.0\n\nmixing_time_bound = 10.0\ndelta = 0.1\n\nconfig = ThermalizeConfig(\n    num_qubits = num_qubits,\n    with_coherent = with_coherent,\n    with_linear_combination = with_linear_combination,\n    domain = domain,\n    beta = beta,\n    a = a,\n    b = b,\n    num_energy_bits = num_energy_bits,\n    w0 = w0,\n    t0 = t0,\n    mixing_time = mixing_time_bound,\n    delta = delta,\n);\nnothing #hide","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Domains quad Algorithms are translated to the quantum computer in the form of quantum circuits, a set of unitary quantum gates, that inherently work in the time domain, which is also what we mean by choosing domain to be TimeDomain. More realistically, time evolutions are decomposed into a Trotter product, which is also possible to see in our code via TrotterDomain. Though the original mathematical problem of finding a Lindbladian that evolves the system to the thermal state is formulated in the Bohr and Energy domains, that should pose no problem for us. We can always move from the time domain to the energy domain with the Fourier transform.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Coherent term quad It has been proven (see Theory) that by adding a specific coherent term to the Lindbladian, we can have the Gibbs state as the unique fixed point of the generator. But even if we omit it by setting with_coherent = false, we would find an approximately good (or bad) result.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Linear combinations quad A simpler version of the theory is when we don't take a convex combination of Lindbladians. We can think of this as singling out a thin Gaussian region for which we allow transitions for certain energy differences induced by the jumps. We can also turn on the linear combination option, and thus have more borad transition while keeping the Gibbs state as the target state (see Theory).","category":"page"},{"location":"generated/tutorial_thermalize/#2.-Define-the-system-Hamiltonian","page":"Finding a Thermal State","title":"2. Define the system Hamiltonian","text":"","category":"section"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Next, we will define and construct the Hamiltonian of the subsystem we want to thermalize. We will use the function called create_hamham. If we know how the terms in our Hamiltonian decompose into tensor products of single qubit terms, then this function will generate a Hamiltonian whose spectrum is within [0.0, 0.45] and creates a HamHam object with some other necessary fields in it like its eigenvectors, or its Gibbs state.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"X::Matrix{ComplexF64} = [0 1; 1 0]\nY::Matrix{ComplexF64} = [0.0 -im; im 0.0]\nZ::Matrix{ComplexF64} = [1 0; 0 -1]\n\nhamiltonian_terms = [[X, X], [Y, Y], [Z, Z]]\nhamiltonian_coeffs = fill(1.0, length(hamiltonian_terms))\ndisordering_term = [Z]\ndisordering_coeffs = rand(num_qubits);\nnothing #hide","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Generate a 4-qubit chain antiferromagnetic Heisenberg Hamiltonian with a disordering field","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"hamiltonian = create_hamham(hamiltonian_terms, hamiltonian_coeffs, disordering_term, disordering_coeffs, num_qubits)\nhamiltonian.gibbs = Hermitian(gibbs_state_in_eigen(hamiltonian, beta));\nnothing #hide","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Note that we added here a disordering field to the Hamiltonian in order to make its spectrum unique. A priori the algorithm should also work with degenerate spectra, but a unique one definitely makes things easier to converge. Nevertheless exploring what effects a degenerate spectrum have on the algorithm would be quite interesting too.","category":"page"},{"location":"generated/tutorial_thermalize/#3.-Define-the-jump-operators-for-the-evolution","page":"Finding a Thermal State","title":"3. Define the jump operators for the evolution","text":"","category":"section"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"jump_set = [[X], [Y], [Z]];\nnothing #hide","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"1-site Pauli jumps are generated over each system site and save their form in the eigenbasis we work in for effficiency:","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"jumps::Vector{JumpOp} = []\njump_normalization = sqrt(length(jump_set) * num_qubits)\nfor jump_a in jump_set\n    for site in 1:num_qubits\n        jump_op = Matrix(pad_term(jump_a, num_qubits, site)) / jump_normalization\n        jump_op_in_eigenbasis = hamiltonian.eigvecs' * jump_op * hamiltonian.eigvecs\n        orthogonal = (jump_op == transpose(jump_op))\n        jump = JumpOp(jump_op, jump_op_in_eigenbasis, orthogonal)\n        push!(jumps, jump)\n    end\nend","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Even though it seems unassuming, that we use single-site Pauli jump operators, the actual jumps that are applied to the system are spread out time evolved operators of the form A(t) = f(t) e^iHt A e^-iHt, with some Gaussian filter function f(t). Since the time evolutions can be quite large, while the simulable systems quite small, the actual jumps are effectively full system sized in most cases. The jump normalization is required for the block encoding in the algorithm, as the operators should have a norm less than or equal to 1.","category":"page"},{"location":"generated/tutorial_thermalize/#4.-Find-the-thermal-state","page":"Finding a Thermal State","title":"4. Find the thermal state","text":"","category":"section"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Finally we can run the core function, that we will evolve the initial state by approximated Lindbladian evolution, always a delta step at a time. The result then will be deviating by mathcalO(delta^2) errors from the target Gibbs state.","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"initial_dm = Matrix{ComplexF64}(I(dim) / dim);\nnothing #hide","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"Evolve the system:","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"results = run_thermalization(jumps, config, initial_dm, hamiltonian)\n\nprintln(\"\\n Last distance to Gibbs: %s\\n\", results.distances_to_gibbs[end])","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"","category":"page"},{"location":"generated/tutorial_thermalize/","page":"Finding a Thermal State","title":"Finding a Thermal State","text":"This page was generated using Literate.jl.","category":"page"}]
}
